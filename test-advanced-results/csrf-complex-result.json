{
  "vulnerabilities": [
    {
      "id": "9e7c3ff7-a6cd-418b-8eef-4b03c66ed105",
      "type": "insecureCookieSettings",
      "severity": "high",
      "title": "Insecure Cookie Settings",
      "description": "This code sets cookies without the Secure and HttpOnly flags, making them vulnerable to theft via XSS attacks and man-in-the-middle attacks.",
      "code": "...// Set as cookie without Secure flag\ndocument.cookie = `csrf_token = ${\ntoken};\npath =/`;\n...",
      "line": 27,
      "column": 1,
      "recommendation": "Always set Secure and HttpOnly flags for cookies containing sensitive information.",
      "recommendationCode": "// UNSAFE:\n// document.cookie = \"sessionId=abc123; path=/\";\n\n// SAFE:\n// Secure cookie example (shown in comments to avoid execution issues)\n/*\nfunction setSecureCookie(name, value, options = {}) {\n  // Default options - secure by default\n  const defaultOptions = {\n    path: '/',\n    secure: true,         // Only sent over HTTPS\n    sameSite: 'strict',   // Protects against CSRF\n    maxAge: 3600          // 1 hour in seconds\n  };\n  \n  const cookieOptions = {...defaultOptions, ...options};\n  \n  // Build cookie string\n  let cookieString = encodeURIComponent(name) + \"=\" + encodeURIComponent(value);\n  \n  // Add options\n  if (cookieOptions.path) cookieString += \"; path=\" + cookieOptions.path;\n  if (cookieOptions.domain) cookieString += \"; domain=\" + cookieOptions.domain;\n  if (cookieOptions.maxAge) cookieString += \"; max-age=\" + cookieOptions.maxAge;\n  if (cookieOptions.expires) cookieString += \"; expires=\" + cookieOptions.expires.toUTCString();\n  if (cookieOptions.secure) cookieString += \"; secure\";\n  if (cookieOptions.sameSite) cookieString += \"; samesite=\" + cookieOptions.sameSite;\n  \n  // Set the cookie\n  document.cookie = cookieString;\n}\n\n// Usage:\nsetSecureCookie('sessionId', 'abc123', {\n  secure: true,\n  sameSite: 'strict'\n});\n\n// NOTE: For sensitive cookies like session IDs, they should be set server-side\n// with the HttpOnly flag, which prevents JavaScript access\n*/"
    },
    {
      "id": "669e6e13-bf90-47e2-91d6-1427476271cf",
      "type": "missingSameSiteCookieAttribute",
      "severity": "high",
      "title": "Missing SameSite Cookie Attribute",
      "description": "This code sets or configures cookies without specifying the SameSite attribute, which is a critical defense against CSRF attacks. Modern browsers require explicit SameSite settings.",
      "code": "...// Set as cookie without Secure flag\ndocument.cookie = `csrf_token = ${\ntoken};\n...",
      "line": 27,
      "column": 1,
      "recommendation": "Always set the SameSite attribute to 'Strict' or 'Lax' for all cookies, especially authentication cookies.",
      "recommendationCode": "// UNSAFE - Missing SameSite attribute\n// document.cookie = \"sessionId=abc123; path=/; secure\";\n// \n// app.use(cookieSession({\n//   secret: 'secret-key',\n//   maxAge: 24 * 60 * 60 * 1000 // 24 hours\n// }));\n\n// SAFE - With SameSite (client-side)\ndocument.cookie = \"userPrefs=theme:dark; path=/; secure; SameSite=Lax\";\n\n// SAFE - With SameSite (server-side)\napp.use(cookieSession({\n  name: 'session',\n  secret: 'keyboard cat',\n  maxAge: 24 * 60 * 60 * 1000, // 24 hours\n  sameSite: 'strict',          // Prevent CSRF\n  secure: true,                // HTTPS only\n  httpOnly: true               // Inaccessible to JavaScript\n}));\n\n// For Express.js response:\nres.cookie('sessionId', 'abc123', {\n  httpOnly: true,\n  secure: true,\n  sameSite: 'strict'\n});"
    },
    {
      "id": "f79953a1-2cf7-46c6-8fd7-02ed614d9d71",
      "type": "improperDoubleSubmitCookieImplementation",
      "severity": "high",
      "title": "Insecure CSRF Token Validation",
      "description": "This code implements CSRF token validation without using constant-time comparison, making it vulnerable to timing attacks that could bypass the protection.",
      "code": "...// 3. CSRF protection with insufficient token comparison\nfunction validateCsrfToken (request) {\n  const tokenFromCookie = getCookie ('csrf_token');\n  const tokenFromHeader = request.headers['x - csrf - token'];\n  // Vulnerable: Compares only first 5 characters, making brute force easier\n  return tokenFromCookie.substring (0, 5) === tokenFromHeader.substring (0, 5);\n}\n...",
      "line": 43,
      "column": 1,
      "recommendation": "Always use constant-time comparison functions when validating security tokens to prevent timing attacks.",
      "recommendationCode": "// UNSAFE - Regular string comparison vulnerable to timing attacks\n// function validateCSRFToken(req) {\n//   const cookieToken = req.cookies.csrf;\n//   const headerToken = req.headers['x-csrf-token'];\n//   return cookieToken === headerToken; // Timing attack vulnerability\n// }\n\n// SAFE - Use constant-time comparison\nconst crypto = require('crypto');\n\nfunction validateCSRFToken(req) {\n  const cookieToken = req.cookies.csrf;\n  const headerToken = req.headers['x-csrf-token'];\n  \n  // Validate inputs exist\n  if (!cookieToken || !headerToken) {\n    return false;\n  }\n  \n  // Use constant-time comparison to prevent timing attacks\n  // This is critical for security token validation\n  try {\n    return crypto.timingSafeEqual(\n      Buffer.from(cookieToken, 'utf8'),\n      Buffer.from(headerToken, 'utf8')\n    );\n  } catch (e) {\n    console.error('CSRF validation error:', e);\n    return false;\n  }\n}\n\n// For Express middleware\nfunction csrfProtection(req, res, next) {\n  if (req.method === 'GET') {\n    // Generate new token for GET requests\n    const newToken = crypto.randomBytes(32).toString('hex');\n    res.cookie('csrf', newToken, { \n      httpOnly: true, \n      secure: true,\n      sameSite: 'strict'\n    });\n    res.locals.csrfToken = newToken; // Available for templates\n    next();\n  } else {\n    // Validate token for state-changing requests (POST, PUT, DELETE)\n    if (validateCSRFToken(req)) {\n      next();\n    } else {\n      res.status(403).send('CSRF token validation failed');\n    }\n  }\n}"
    },
    {
      "id": "4ce1437b-a78d-4717-9976-006b1d650ada",
      "type": "domClobberingViaID",
      "severity": "medium",
      "title": "Potential DOM Clobbering Vulnerability",
      "description": "Using getElementById with variable inputs can be exploited via DOM clobbering attacks, where attackers inject elements with controlled IDs.",
      "code": "...function updateUserProfileCsrf (userId, userData) {\n  const token = document.getElementById ('csrf - token').value;\n  fetch ('/ api / user /' + userId, {\n    ...",
      "line": 6,
      "column": 23,
      "recommendation": "Use constant, hardcoded IDs with getElementById or validate ID inputs against a strict allowlist.",
      "recommendationCode": "// UNSAFE patterns:\n// const element = document.getElementById(userProvidedId);\n// document.getElementById(params.get('section')).innerHTML = content;\n\n// SAFER approaches:\n// Option 1: Use hardcoded IDs (preferred)\nconst element = document.getElementById('user-profile');\n\n// Option 2: If dynamic IDs are needed, validate against an allowlist\nfunction getElementByValidatedId(id) {\n  // Define allowed IDs\n  const allowedIds = ['profile', 'settings', 'dashboard', 'messages'];\n  \n  // Validate the ID\n  if (typeof id !== 'string' || !allowedIds.includes(id)) {\n    console.error('Invalid or disallowed element ID:', id);\n    return null;\n  }\n  \n  return document.getElementById(id);\n}\n\n// Usage:\nconst section = getElementByValidatedId(sectionId);\nif (section) {\n  section.textContent = data;\n}"
    },
    {
      "id": "81474b48-ccf6-4b57-a5c2-ddef3b19d7cc",
      "type": "domClobberingViaID",
      "severity": "medium",
      "title": "Potential DOM Clobbering Vulnerability",
      "description": "Using getElementById with variable inputs can be exploited via DOM clobbering attacks, where attackers inject elements with controlled IDs.",
      "code": "...function loadPageWithTokenInUrl () {\n  const token = document.getElementById ('csrf - token').value;\n  // Putting CSRF token in URL is unsafe - can leak via Referer header\n  ...",
      "line": 92,
      "column": 23,
      "recommendation": "Use constant, hardcoded IDs with getElementById or validate ID inputs against a strict allowlist.",
      "recommendationCode": "// UNSAFE patterns:\n// const element = document.getElementById(userProvidedId);\n// document.getElementById(params.get('section')).innerHTML = content;\n\n// SAFER approaches:\n// Option 1: Use hardcoded IDs (preferred)\nconst element = document.getElementById('user-profile');\n\n// Option 2: If dynamic IDs are needed, validate against an allowlist\nfunction getElementByValidatedId(id) {\n  // Define allowed IDs\n  const allowedIds = ['profile', 'settings', 'dashboard', 'messages'];\n  \n  // Validate the ID\n  if (typeof id !== 'string' || !allowedIds.includes(id)) {\n    console.error('Invalid or disallowed element ID:', id);\n    return null;\n  }\n  \n  return document.getElementById(id);\n}\n\n// Usage:\nconst section = getElementByValidatedId(sectionId);\nif (section) {\n  section.textContent = data;\n}"
    },
    {
      "id": "e54c1225-08bd-48d7-9dbe-68630d468244",
      "type": "aHref",
      "severity": "medium",
      "title": "Direct href Property Assignment",
      "description": "Setting the href property directly with user input can lead to javascript: protocol exploits.",
      "code": "...// Putting CSRF token in URL is unsafe - can leak via Referer header\nwindow.location.href = `/ dashboard?csrf_token = ${\ntoken}\n`;\n}\n...",
      "line": 94,
      "column": 16,
      "recommendation": "Validate URLs before assigning to href properties.",
      "recommendationCode": "function setLinkHref(element, url) {\n  // Validate URL format and protocol\n  if (!url.match(/^(https?:\\/\\/|\\/|\\.\\/|\\.\\.\\/)[\\w\\d\\-\\.\\/\\?\\=\\&\\%\\+\\#\\:]*/i) || \n      /^javascript:|^data:|^vbscript:|^file:/i.test(url)) {\n    console.error(\"Invalid or potentially malicious URL\");\n    return;\n  }\n  \n  element.href = url;\n}"
    },
    {
      "id": "2f4d3af2-1039-4b56-b2be-53750651b5cc",
      "type": "dangerousAnchorHref",
      "severity": "medium",
      "title": "Potentially Dangerous Link Target",
      "description": "Setting href attributes without proper validation can lead to javascript: URI or data: URI based XSS attacks.",
      "code": "...// Putting CSRF token in URL is unsafe - can leak via Referer header\nwindow.location.href = `/ dashboard?csrf_token = ${\ntoken}\n...",
      "line": 94,
      "column": 16,
      "recommendation": "Validate all URLs before setting as href attributes. Ensure they use safe protocols like http:, https:, mailto:, or tel:.",
      "recommendationCode": "// UNSAFE patterns:\n// link.href = userInput;\n// document.getElementById('download').href = getFileUrl(fileName);\n\n// SAFER approach:\nfunction setLinkUrl(linkElement, url) {\n  // Function to validate URL safety\n  function isUrlSafe(url) {\n    // Safe if it's relative\n    if (url.startsWith('/') || url.startsWith('./') || url.startsWith('../')) {\n      return true;\n    }\n    \n    // Check for safe protocols\n    const safeProtocols = ['http:', 'https:', 'mailto:', 'tel:'];\n    try {\n      const parsedUrl = new URL(url);\n      return safeProtocols.includes(parsedUrl.protocol);\n    } catch (e) {\n      // If parsing fails, it's not a valid URL\n      return false;\n    }\n  }\n  \n  // Remove dangerous protocols\n  function sanitizeUrl(url) {\n    // Simple cleaning for javascript: and data: URIs\n    if (/^(?:javascript|data|vbscript|file):/i.test(url)) {\n      return '#'; // Replace with harmless fragment\n    }\n    return url;\n  }\n  \n  // Check and set the URL\n  if (isUrlSafe(url)) {\n    linkElement.href = url;\n  } else {\n    console.error('Unsafe URL blocked:', url);\n    linkElement.href = '#'; // Set to safe default\n    // Optionally disable the link\n    linkElement.style.pointerEvents = 'none';\n    linkElement.style.color = 'gray';\n    linkElement.title = 'Link disabled - unsafe URL';\n  }\n}"
    },
    {
      "id": "49569fb8-01e5-4b19-ba9a-89e913e15475",
      "type": "domClobberingViaID",
      "severity": "medium",
      "title": "Potential DOM Clobbering Vulnerability",
      "description": "Using getElementById with variable inputs can be exploited via DOM clobbering attacks, where attackers inject elements with controlled IDs.",
      "code": "...// First step stores token but doesn't validate it\nconst firstStepForm = document.getElementById ('step1 - form');\nfirstStepForm.addEventListener ('submit', function (e) {\n  ...",
      "line": 101,
      "column": 31,
      "recommendation": "Use constant, hardcoded IDs with getElementById or validate ID inputs against a strict allowlist.",
      "recommendationCode": "// UNSAFE patterns:\n// const element = document.getElementById(userProvidedId);\n// document.getElementById(params.get('section')).innerHTML = content;\n\n// SAFER approaches:\n// Option 1: Use hardcoded IDs (preferred)\nconst element = document.getElementById('user-profile');\n\n// Option 2: If dynamic IDs are needed, validate against an allowlist\nfunction getElementByValidatedId(id) {\n  // Define allowed IDs\n  const allowedIds = ['profile', 'settings', 'dashboard', 'messages'];\n  \n  // Validate the ID\n  if (typeof id !== 'string' || !allowedIds.includes(id)) {\n    console.error('Invalid or disallowed element ID:', id);\n    return null;\n  }\n  \n  return document.getElementById(id);\n}\n\n// Usage:\nconst section = getElementByValidatedId(sectionId);\nif (section) {\n  section.textContent = data;\n}"
    },
    {
      "id": "a39eeef7-08ff-41bb-9026-c74c0079d26c",
      "type": "domClobberingViaID",
      "severity": "medium",
      "title": "Potential DOM Clobbering Vulnerability",
      "description": "Using getElementById with variable inputs can be exploited via DOM clobbering attacks, where attackers inject elements with controlled IDs.",
      "code": "...// Final submission also lacks CSRF protection\nconst finalStepForm = document.getElementById ('step3 - form');\nfinalStepForm.addEventListener ('submit', function (e) {\n  ...",
      "line": 112,
      "column": 31,
      "recommendation": "Use constant, hardcoded IDs with getElementById or validate ID inputs against a strict allowlist.",
      "recommendationCode": "// UNSAFE patterns:\n// const element = document.getElementById(userProvidedId);\n// document.getElementById(params.get('section')).innerHTML = content;\n\n// SAFER approaches:\n// Option 1: Use hardcoded IDs (preferred)\nconst element = document.getElementById('user-profile');\n\n// Option 2: If dynamic IDs are needed, validate against an allowlist\nfunction getElementByValidatedId(id) {\n  // Define allowed IDs\n  const allowedIds = ['profile', 'settings', 'dashboard', 'messages'];\n  \n  // Validate the ID\n  if (typeof id !== 'string' || !allowedIds.includes(id)) {\n    console.error('Invalid or disallowed element ID:', id);\n    return null;\n  }\n  \n  return document.getElementById(id);\n}\n\n// Usage:\nconst section = getElementByValidatedId(sectionId);\nif (section) {\n  section.textContent = data;\n}"
    },
    {
      "id": "5d86d80b-6676-47fe-86a0-6ae0615c2de0",
      "type": "jsonParse",
      "severity": "medium",
      "title": "Potential JSON Injection",
      "description": "Using JSON.parse on unsanitized input can lead to prototype pollution or other injection attacks.",
      "code": "...// Combine all steps' data\nconst step1Data = JSON.parse (sessionStorage.getItem ('step1 - data'));\nconst step2Data = JSON.parse (sessionStorage.getItem ('step2 - data'));\n...",
      "line": 116,
      "column": 19,
      "recommendation": "Validate JSON input before parsing and consider using a safer JSON parsing library.",
      "recommendationCode": "// Before using JSON.parse:\nfunction safeJSONParse(data) {\n  // Check if data is a string\n  if (typeof data !== 'string') {\n    throw new Error('Invalid input: expected string');\n  }\n  \n  // Optional: Check for suspicious patterns\n  if (/\\__proto__|constructor|prototype/.test(data)) {\n    throw new Error('Potentially malicious input detected');\n  }\n  \n  try {\n    return JSON.parse(data);\n  } catch (e) {\n    console.error('JSON parsing error:', e);\n    throw new Error('Invalid JSON format');\n  }\n}"
    },
    {
      "id": "a2ae16e0-b125-4f5a-b77e-2f372717dc2e",
      "type": "jsonParseVulnerability",
      "severity": "medium",
      "title": "Unsafe JSON.parse Usage",
      "description": "Using JSON.parse with unvalidated input can lead to unexpected JavaScript execution in certain browsers or throw exceptions that could disrupt application flow.",
      "code": "...// Combine all steps' data\nconst step1Data = JSON.parse (sessionStorage.getItem ('step1 - data'));\nconst step2Data = JSON.parse (sessionStorage.getItem ('step2 - data'));\n...",
      "line": 116,
      "column": 19,
      "recommendation": "Always validate JSON input before parsing and implement proper error handling around JSON.parse operations.",
      "recommendationCode": "// UNSAFE:\n// const data = JSON.parse(userProvidedJsonString);\n\n// SAFER:\nfunction safeJsonParse(jsonString) {\n  // 1. Validate input type\n  if (typeof jsonString !== 'string') {\n    console.error('Invalid JSON input type');\n    return null;\n  }\n  \n  // 2. Validate JSON structure (optional additional validation)\n  if (!/^[\\[\\{].*[\\}\\]]$/.test(jsonString.trim())) {\n    console.error('Invalid JSON structure');\n    return null;\n  }\n  \n  // 3. Use try-catch to handle parsing errors\n  try {\n    const data = JSON.parse(jsonString);\n    \n    // 4. Optional: Validate parsed data against expected schema\n    // validateAgainstSchema(data);\n    \n    return data;\n  } catch (error) {\n    console.error('JSON parsing error:', error);\n    return null;\n  }\n}"
    },
    {
      "id": "8a68f491-285d-4288-bf30-fa7b00efdd86",
      "type": "unsafeJSONParse",
      "severity": "medium",
      "title": "Potentially Unsafe JSON.parse Usage",
      "description": "Using JSON.parse with unsanitized user-controlled data can lead to prototype pollution and other injection vulnerabilities.",
      "code": "...// Combine all steps' data\nconst step1Data = JSON.parse (sessionStorage.getItem ('step1 - data'));\nconst step2Data = JSON.parse (sessionStorage.getItem ('step2 - data'));\n...",
      "line": 116,
      "column": 19,
      "recommendation": "Validate JSON input before parsing and use JSON schema validation for complex structures.",
      "recommendationCode": "// UNSAFE patterns:\n// const data = JSON.parse(userInput);\n// const config = JSON.parse(localStorage.getItem('config'));\n\n// SAFER approaches:\n// Option 1: Add validation and error handling\nfunction safeJsonParse(jsonString, defaultValue = {}) {\n  try {\n    if (typeof jsonString !== 'string') {\n      return defaultValue;\n    }\n    \n    // Optional: simple validation for very basic JSON format\n    if (!jsonString.match(/^\\s*({|\\[)/)) {\n      console.error('Invalid JSON format detected');\n      return defaultValue;\n    }\n    \n    const result = JSON.parse(jsonString);\n    \n    // Simple prototype pollution protection\n    if (result && typeof result === 'object' && result.__proto__) {\n      delete result.__proto__;\n    }\n    \n    return result;\n  } catch (e) {\n    console.error('JSON parsing failed:', e);\n    return defaultValue;\n  }\n}\n\n// Option 2: Using JSON schema validation for more control\n// npm install ajv\nimport Ajv from 'ajv';\n\nfunction validateJsonWithSchema(json, schema) {\n  const ajv = new Ajv();\n  const validate = ajv.compile(schema);\n  \n  let data;\n  try {\n    data = (typeof json === 'string') ? JSON.parse(json) : json;\n  } catch (e) {\n    console.error('Invalid JSON:', e);\n    return null;\n  }\n  \n  const valid = validate(data);\n  if (!valid) {\n    console.error('Schema validation failed:', validate.errors);\n    return null;\n  }\n  \n  return data;\n}\n\n// Usage example:\nconst userSchema = {\n  type: 'object',\n  properties: {\n    id: { type: 'number' },\n    name: { type: 'string' },\n    email: { type: 'string', format: 'email' }\n  },\n  required: ['id', 'name', 'email'],\n  additionalProperties: false // Prevents extra properties\n};\n\nconst userData = validateJsonWithSchema(userInputJSON, userSchema);\nif (userData) {\n  // Safe to use the data\n  processUser(userData);\n}"
    },
    {
      "id": "ee6b8d2d-cc75-4791-94c8-7d16d4936ea8",
      "type": "vulnerableJsonParse",
      "severity": "medium",
      "title": "Unsafe JSON Parsing",
      "description": "Parsing JSON from untrusted sources can lead to prototype pollution or DoS attacks with carefully crafted payloads.",
      "code": "...// Combine all steps' data\nconst step1Data = JSON.parse (sessionStorage.getItem ('step1 - data'));\nconst step2Data = JSON.parse (sessionStorage.getItem ('step2 - data'));\n...",
      "line": 116,
      "column": 19,
      "recommendation": "Always validate JSON structure and use a JSON schema validator before parsing sensitive data.",
      "recommendationCode": "// Import a JSON schema validator like Ajv\nimport Ajv from 'ajv';\n\n// Define a schema for expected JSON structure\nconst userSchema = {\n  type: 'object',\n  properties: {\n    id: { type: 'number' },\n    name: { type: 'string', maxLength: 100 },\n    email: { type: 'string', format: 'email' },\n    preferences: {\n      type: 'object',\n      properties: {\n        theme: { type: 'string', enum: ['light', 'dark', 'system'] },\n        notifications: { type: 'boolean' }\n      },\n      additionalProperties: false\n    }\n  },\n  required: ['id', 'name', 'email'],\n  additionalProperties: false\n};\n\n// Safely parse and validate JSON\nfunction safeJsonParse(jsonString) {\n  try {\n    // First parse the JSON\n    const data = JSON.parse(jsonString);\n    \n    // Then validate against schema\n    const ajv = new Ajv();\n    const validate = ajv.compile(userSchema);\n    \n    if (validate(data)) {\n      return data;\n    } else {\n      console.error('Invalid data structure:', validate.errors);\n      return null;\n    }\n  } catch (e) {\n    console.error('JSON parsing error:', e);\n    return null;\n  }\n}"
    },
    {
      "id": "cb488a6d-e2fc-431c-851d-f90c51440eab",
      "type": "jsonParse",
      "severity": "medium",
      "title": "Potential JSON Injection",
      "description": "Using JSON.parse on unsanitized input can lead to prototype pollution or other injection attacks.",
      "code": "...const step1Data = JSON.parse (sessionStorage.getItem ('step1 - data'));\nconst step2Data = JSON.parse (sessionStorage.getItem ('step2 - data'));\nconst formData = new FormData (finalStepForm);\n...",
      "line": 117,
      "column": 19,
      "recommendation": "Validate JSON input before parsing and consider using a safer JSON parsing library.",
      "recommendationCode": "// Before using JSON.parse:\nfunction safeJSONParse(data) {\n  // Check if data is a string\n  if (typeof data !== 'string') {\n    throw new Error('Invalid input: expected string');\n  }\n  \n  // Optional: Check for suspicious patterns\n  if (/\\__proto__|constructor|prototype/.test(data)) {\n    throw new Error('Potentially malicious input detected');\n  }\n  \n  try {\n    return JSON.parse(data);\n  } catch (e) {\n    console.error('JSON parsing error:', e);\n    throw new Error('Invalid JSON format');\n  }\n}"
    },
    {
      "id": "1529a8f5-66c4-4f25-ab86-d598698dfa86",
      "type": "jsonParseVulnerability",
      "severity": "medium",
      "title": "Unsafe JSON.parse Usage",
      "description": "Using JSON.parse with unvalidated input can lead to unexpected JavaScript execution in certain browsers or throw exceptions that could disrupt application flow.",
      "code": "...const step1Data = JSON.parse (sessionStorage.getItem ('step1 - data'));\nconst step2Data = JSON.parse (sessionStorage.getItem ('step2 - data'));\nconst formData = new FormData (finalStepForm);\n...",
      "line": 117,
      "column": 19,
      "recommendation": "Always validate JSON input before parsing and implement proper error handling around JSON.parse operations.",
      "recommendationCode": "// UNSAFE:\n// const data = JSON.parse(userProvidedJsonString);\n\n// SAFER:\nfunction safeJsonParse(jsonString) {\n  // 1. Validate input type\n  if (typeof jsonString !== 'string') {\n    console.error('Invalid JSON input type');\n    return null;\n  }\n  \n  // 2. Validate JSON structure (optional additional validation)\n  if (!/^[\\[\\{].*[\\}\\]]$/.test(jsonString.trim())) {\n    console.error('Invalid JSON structure');\n    return null;\n  }\n  \n  // 3. Use try-catch to handle parsing errors\n  try {\n    const data = JSON.parse(jsonString);\n    \n    // 4. Optional: Validate parsed data against expected schema\n    // validateAgainstSchema(data);\n    \n    return data;\n  } catch (error) {\n    console.error('JSON parsing error:', error);\n    return null;\n  }\n}"
    },
    {
      "id": "def78dbc-e0c6-402f-b2a1-6d5f34f17504",
      "type": "unsafeJSONParse",
      "severity": "medium",
      "title": "Potentially Unsafe JSON.parse Usage",
      "description": "Using JSON.parse with unsanitized user-controlled data can lead to prototype pollution and other injection vulnerabilities.",
      "code": "...const step1Data = JSON.parse (sessionStorage.getItem ('step1 - data'));\nconst step2Data = JSON.parse (sessionStorage.getItem ('step2 - data'));\nconst formData = new FormData (finalStepForm);\n...",
      "line": 117,
      "column": 19,
      "recommendation": "Validate JSON input before parsing and use JSON schema validation for complex structures.",
      "recommendationCode": "// UNSAFE patterns:\n// const data = JSON.parse(userInput);\n// const config = JSON.parse(localStorage.getItem('config'));\n\n// SAFER approaches:\n// Option 1: Add validation and error handling\nfunction safeJsonParse(jsonString, defaultValue = {}) {\n  try {\n    if (typeof jsonString !== 'string') {\n      return defaultValue;\n    }\n    \n    // Optional: simple validation for very basic JSON format\n    if (!jsonString.match(/^\\s*({|\\[)/)) {\n      console.error('Invalid JSON format detected');\n      return defaultValue;\n    }\n    \n    const result = JSON.parse(jsonString);\n    \n    // Simple prototype pollution protection\n    if (result && typeof result === 'object' && result.__proto__) {\n      delete result.__proto__;\n    }\n    \n    return result;\n  } catch (e) {\n    console.error('JSON parsing failed:', e);\n    return defaultValue;\n  }\n}\n\n// Option 2: Using JSON schema validation for more control\n// npm install ajv\nimport Ajv from 'ajv';\n\nfunction validateJsonWithSchema(json, schema) {\n  const ajv = new Ajv();\n  const validate = ajv.compile(schema);\n  \n  let data;\n  try {\n    data = (typeof json === 'string') ? JSON.parse(json) : json;\n  } catch (e) {\n    console.error('Invalid JSON:', e);\n    return null;\n  }\n  \n  const valid = validate(data);\n  if (!valid) {\n    console.error('Schema validation failed:', validate.errors);\n    return null;\n  }\n  \n  return data;\n}\n\n// Usage example:\nconst userSchema = {\n  type: 'object',\n  properties: {\n    id: { type: 'number' },\n    name: { type: 'string' },\n    email: { type: 'string', format: 'email' }\n  },\n  required: ['id', 'name', 'email'],\n  additionalProperties: false // Prevents extra properties\n};\n\nconst userData = validateJsonWithSchema(userInputJSON, userSchema);\nif (userData) {\n  // Safe to use the data\n  processUser(userData);\n}"
    },
    {
      "id": "c9da64bd-e5f5-401e-96e2-a05536d777ec",
      "type": "vulnerableJsonParse",
      "severity": "medium",
      "title": "Unsafe JSON Parsing",
      "description": "Parsing JSON from untrusted sources can lead to prototype pollution or DoS attacks with carefully crafted payloads.",
      "code": "...const step1Data = JSON.parse (sessionStorage.getItem ('step1 - data'));\nconst step2Data = JSON.parse (sessionStorage.getItem ('step2 - data'));\nconst formData = new FormData (finalStepForm);\n...",
      "line": 117,
      "column": 19,
      "recommendation": "Always validate JSON structure and use a JSON schema validator before parsing sensitive data.",
      "recommendationCode": "// Import a JSON schema validator like Ajv\nimport Ajv from 'ajv';\n\n// Define a schema for expected JSON structure\nconst userSchema = {\n  type: 'object',\n  properties: {\n    id: { type: 'number' },\n    name: { type: 'string', maxLength: 100 },\n    email: { type: 'string', format: 'email' },\n    preferences: {\n      type: 'object',\n      properties: {\n        theme: { type: 'string', enum: ['light', 'dark', 'system'] },\n        notifications: { type: 'boolean' }\n      },\n      additionalProperties: false\n    }\n  },\n  required: ['id', 'name', 'email'],\n  additionalProperties: false\n};\n\n// Safely parse and validate JSON\nfunction safeJsonParse(jsonString) {\n  try {\n    // First parse the JSON\n    const data = JSON.parse(jsonString);\n    \n    // Then validate against schema\n    const ajv = new Ajv();\n    const validate = ajv.compile(userSchema);\n    \n    if (validate(data)) {\n      return data;\n    } else {\n      console.error('Invalid data structure:', validate.errors);\n      return null;\n    }\n  } catch (e) {\n    console.error('JSON parsing error:', e);\n    return null;\n  }\n}"
    },
    {
      "id": "d0b1786a-6fd3-467a-a7f9-bf80d3db162f",
      "type": "domClobberingViaID",
      "severity": "medium",
      "title": "Potential DOM Clobbering Vulnerability",
      "description": "Using getElementById with variable inputs can be exploited via DOM clobbering attacks, where attackers inject elements with controlled IDs.",
      "code": "...function loadResourcesWithTokenLeakage () {\n  const token = document.getElementById ('csrf - token').value;\n  // Load resources from third - party sites with token in URL\n  ...",
      "line": 139,
      "column": 23,
      "recommendation": "Use constant, hardcoded IDs with getElementById or validate ID inputs against a strict allowlist.",
      "recommendationCode": "// UNSAFE patterns:\n// const element = document.getElementById(userProvidedId);\n// document.getElementById(params.get('section')).innerHTML = content;\n\n// SAFER approaches:\n// Option 1: Use hardcoded IDs (preferred)\nconst element = document.getElementById('user-profile');\n\n// Option 2: If dynamic IDs are needed, validate against an allowlist\nfunction getElementByValidatedId(id) {\n  // Define allowed IDs\n  const allowedIds = ['profile', 'settings', 'dashboard', 'messages'];\n  \n  // Validate the ID\n  if (typeof id !== 'string' || !allowedIds.includes(id)) {\n    console.error('Invalid or disallowed element ID:', id);\n    return null;\n  }\n  \n  return document.getElementById(id);\n}\n\n// Usage:\nconst section = getElementByValidatedId(sectionId);\nif (section) {\n  section.textContent = data;\n}"
    },
    {
      "id": "2858bb91-42b7-47ca-acb4-09475eb7472f",
      "type": "documentGetElementById",
      "severity": "low",
      "title": "Potential DOM Clobbering Vulnerability",
      "description": "Using getElementById with a fixed string can be exploited through DOM clobbering if the ID is also used as an object property.",
      "code": "...function updateUserProfileCsrf (userId, userData) {\n  const token = document.getElementById ('csrf - token').value;\n  fetch ('/ api / user /' + userId, {\n    ...",
      "line": 6,
      "column": 15,
      "recommendation": "Ensure IDs used with getElementById are not also used as object property names in your code.",
      "recommendationCode": "// Vulnerable pattern:\n// const config = {};\n// config.endpoint = document.getElementById('endpoint').value;\n// fetch(config.endpoint + '/data');\n\n// Safer approach:\nfunction getElementValueById(id) {\n  const element = document.getElementById(id);\n  // Validate element is of expected type\n  if (element && element instanceof HTMLInputElement) {\n    return element.value;\n  }\n  return null;\n}\n\n// Then use with validation:\nconst endpoint = getElementValueById('endpoint');\nif (endpoint && isValidUrl(endpoint)) {\n  fetch(endpoint + '/data');\n}"
    },
    {
      "id": "4d8b91c9-bf45-4aec-8d1c-5657892545a7",
      "type": "documentGetElementById",
      "severity": "low",
      "title": "Potential DOM Clobbering Vulnerability",
      "description": "Using getElementById with a fixed string can be exploited through DOM clobbering if the ID is also used as an object property.",
      "code": "...function loadPageWithTokenInUrl () {\n  const token = document.getElementById ('csrf - token').value;\n  // Putting CSRF token in URL is unsafe - can leak via Referer header\n  ...",
      "line": 92,
      "column": 15,
      "recommendation": "Ensure IDs used with getElementById are not also used as object property names in your code.",
      "recommendationCode": "// Vulnerable pattern:\n// const config = {};\n// config.endpoint = document.getElementById('endpoint').value;\n// fetch(config.endpoint + '/data');\n\n// Safer approach:\nfunction getElementValueById(id) {\n  const element = document.getElementById(id);\n  // Validate element is of expected type\n  if (element && element instanceof HTMLInputElement) {\n    return element.value;\n  }\n  return null;\n}\n\n// Then use with validation:\nconst endpoint = getElementValueById('endpoint');\nif (endpoint && isValidUrl(endpoint)) {\n  fetch(endpoint + '/data');\n}"
    },
    {
      "id": "5616ace0-ddba-4975-8a2b-5100cefffdc0",
      "type": "documentGetElementById",
      "severity": "low",
      "title": "Potential DOM Clobbering Vulnerability",
      "description": "Using getElementById with a fixed string can be exploited through DOM clobbering if the ID is also used as an object property.",
      "code": "...// First step stores token but doesn't validate it\nconst firstStepForm = document.getElementById ('step1 - form');\nfirstStepForm.addEventListener ('submit', function (e) {\n  ...",
      "line": 101,
      "column": 23,
      "recommendation": "Ensure IDs used with getElementById are not also used as object property names in your code.",
      "recommendationCode": "// Vulnerable pattern:\n// const config = {};\n// config.endpoint = document.getElementById('endpoint').value;\n// fetch(config.endpoint + '/data');\n\n// Safer approach:\nfunction getElementValueById(id) {\n  const element = document.getElementById(id);\n  // Validate element is of expected type\n  if (element && element instanceof HTMLInputElement) {\n    return element.value;\n  }\n  return null;\n}\n\n// Then use with validation:\nconst endpoint = getElementValueById('endpoint');\nif (endpoint && isValidUrl(endpoint)) {\n  fetch(endpoint + '/data');\n}"
    },
    {
      "id": "8edb606a-d5b1-455b-ad3a-011a2c8b2424",
      "type": "documentGetElementById",
      "severity": "low",
      "title": "Potential DOM Clobbering Vulnerability",
      "description": "Using getElementById with a fixed string can be exploited through DOM clobbering if the ID is also used as an object property.",
      "code": "...// Final submission also lacks CSRF protection\nconst finalStepForm = document.getElementById ('step3 - form');\nfinalStepForm.addEventListener ('submit', function (e) {\n  ...",
      "line": 112,
      "column": 23,
      "recommendation": "Ensure IDs used with getElementById are not also used as object property names in your code.",
      "recommendationCode": "// Vulnerable pattern:\n// const config = {};\n// config.endpoint = document.getElementById('endpoint').value;\n// fetch(config.endpoint + '/data');\n\n// Safer approach:\nfunction getElementValueById(id) {\n  const element = document.getElementById(id);\n  // Validate element is of expected type\n  if (element && element instanceof HTMLInputElement) {\n    return element.value;\n  }\n  return null;\n}\n\n// Then use with validation:\nconst endpoint = getElementValueById('endpoint');\nif (endpoint && isValidUrl(endpoint)) {\n  fetch(endpoint + '/data');\n}"
    },
    {
      "id": "28771727-61e4-4491-8bdd-c67fa94f0c65",
      "type": "documentGetElementById",
      "severity": "low",
      "title": "Potential DOM Clobbering Vulnerability",
      "description": "Using getElementById with a fixed string can be exploited through DOM clobbering if the ID is also used as an object property.",
      "code": "...function loadResourcesWithTokenLeakage () {\n  const token = document.getElementById ('csrf - token').value;\n  // Load resources from third - party sites with token in URL\n  ...",
      "line": 139,
      "column": 15,
      "recommendation": "Ensure IDs used with getElementById are not also used as object property names in your code.",
      "recommendationCode": "// Vulnerable pattern:\n// const config = {};\n// config.endpoint = document.getElementById('endpoint').value;\n// fetch(config.endpoint + '/data');\n\n// Safer approach:\nfunction getElementValueById(id) {\n  const element = document.getElementById(id);\n  // Validate element is of expected type\n  if (element && element instanceof HTMLInputElement) {\n    return element.value;\n  }\n  return null;\n}\n\n// Then use with validation:\nconst endpoint = getElementValueById('endpoint');\nif (endpoint && isValidUrl(endpoint)) {\n  fetch(endpoint + '/data');\n}"
    },
    {
      "id": "e30e03a7-1270-4065-a798-cf46061bbb01",
      "type": "imageSrcAssignment",
      "severity": "low",
      "title": "Dynamic Image Source Assignment",
      "description": "Setting an image source dynamically is generally safe but may need validation to prevent information leakage or CSP bypass.",
      "code": "...const img = new Image ();\nimg.src = `http:// third - party - cdn.example.com / image.jpg?token = ${\ntoken}\n...",
      "line": 142,
      "column": 1,
      "recommendation": "For dynamic image sources, use a valid URL format and apply proper sanitization if user inputs are involved.",
      "recommendationCode": "// Ensure the path is safe before assigning to image src\nfunction setImageSrc(imagePath, imgElement) {\n  // Sanitize the path if it comes from user input\n  // (Using textContent sanitization is one good approach)\n  const tempNode = document.createTextNode(imagePath);\n  const sanitizedPath = tempNode.textContent;\n  \n  // Validate the path format if needed\n  if (!sanitizedPath.match(/^(https?:\\/\\/|\\/|\\.\\/)[\\w\\d\\-\\.\\/\\?\\=\\&\\%\\+\\#\\:]+$/i)) {\n    console.error('Invalid image path format');\n    return false;\n  }\n  \n  imgElement.src = sanitizedPath;\n  return true;\n}"
    },
    {
      "id": "13887164-59c2-4603-a093-72f83b094239",
      "type": "urlConstruction",
      "severity": "low",
      "title": "Unsafe URL Construction",
      "description": "Constructing URLs by concatenating strings or using template literals can introduce URL injection vulnerabilities if not properly validated.",
      "code": "...const img = new Image ();\nimg.src = `http:// third - party - cdn.example.com / image.jpg?token = ${\ntoken}\n...",
      "line": 142,
      "column": 11,
      "recommendation": "Use URL constructor or URLSearchParams to safely build URLs with user input.",
      "recommendationCode": "// Instead of direct concatenation:\n// const url = 'https://example.com/?q=' + userInput;\n\n// Use URL and URLSearchParams:\nconst baseUrl = 'https://example.com/';\nconst url = new URL(baseUrl);\nurl.searchParams.append('q', userInput);\n\n// Result: safe URL with properly encoded parameters\nfetch(url.toString())\n  .then(response => response.json())\n  .then(data => console.log(data));"
    },
    {
      "id": "71b3007c-771c-43b8-8c9e-a9f064278c1d",
      "type": "clientSideValidation",
      "severity": "low",
      "title": "Client-Side Only Validation",
      "description": "Relying solely on client-side validation can be bypassed by attackers. While not directly an XSS issue, it can contribute to security risks.",
      "code": "...=`);\nif (parts.length === 2) return parts.pop ().split (';\n').shift ();\n...",
      "line": 226,
      "column": 1,
      "recommendation": "Always implement server-side validation alongside client-side validation for a strong security posture.",
      "recommendationCode": "// Client side validation (good for UX)\nfunction validateClientSide(input) {\n  if (!input || input.length > 100) {\n    showError('Input too long or empty');\n    return false;\n  }\n  return true;\n}\n\n// Server side validation (REQUIRED for security)\n// In your server code:\nfunction validateServerSide(input) {\n  if (!input || typeof input !== 'string' || input.length > 100) {\n    return { valid: false, error: 'Invalid input' };\n  }\n  // Additional checks as necessary\n  return { valid: true };\n}"
    }
  ],
  "summary": {
    "critical": 0,
    "high": 3,
    "medium": 15,
    "low": 8,
    "info": 0,
    "total": 26,
    "uniqueTypes": 14,
    "passedChecks": 143
  },
  "scannedAt": "2025-03-27T11:36:25.506Z"
}