{
  "vulnerabilities": [
    {
      "id": "064b73be-ee51-4d9a-a464-0c727a0a567c",
      "type": "scriptCreation",
      "severity": "high",
      "title": "Dynamic Script Creation",
      "description": "Creating script elements dynamically can lead to code injection vulnerabilities, especially when the source or content is influenced by user input.",
      "code": "...const url = protocol + '://' + data.domain + '/ api?query =' + data.query;\nconst script = document.createElement ('script');\nscript.src = url;\n...",
      "line": 66,
      "column": 25,
      "recommendation": "Avoid dynamically creating script elements. If necessary, ensure strict validation of sources and use CSP (Content Security Policy).",
      "recommendationCode": "// UNSAFE:\n// const script = document.createElement('script');\n// script.src = userControlledUrl; // Danger: remote code execution\n// document.head.appendChild(script);\n\n// SAFER approaches:\n// 1. Avoid dynamic script creation entirely, use alternative techniques\n//    like fetch() to retrieve data instead\n\n// 2. If you must create scripts dynamically, implement strict validation\nfunction loadScript(url) {\n  // Validate allowed domains\n  const trustedDomains = ['trusted-cdn.com', 'your-domain.com'];\n  const urlObj = new URL(url);\n  \n  if (!trustedDomains.includes(urlObj.hostname)) {\n    console.error('Script domain not allowed:', urlObj.hostname);\n    return Promise.reject(new Error('Untrusted script domain'));\n  }\n  \n  // Use fetch instead of script injection when possible\n  return fetch(url)\n    .then(response => {\n      if (!response.ok) {\n        throw new Error('Network response was not ok');\n      }\n      return response.text();\n    })\n    .then(code => {\n      // Validate the code before executing it\n      // This is difficult to do safely - consider alternatives\n      \n      // Execute in a controlled manner\n      const functionFromCode = new Function(code);\n      return functionFromCode();\n    });\n}"
    },
    {
      "id": "777a92b0-38c5-4bd5-ad32-f4204e03ddbb",
      "type": "scriptSrc",
      "severity": "high",
      "title": "Dynamic Script Source Assignment",
      "description": "Setting the src property of script elements with user input allows loading and executing untrusted code.",
      "code": "...const script = document.createElement ('script');\nscript.src = url;\n// Should detect this as vulnerable JSONP / script injection\n...",
      "line": 67,
      "column": 1,
      "recommendation": "Always validate script sources against a whitelist of trusted domains.",
      "recommendationCode": "function loadExternalScript(src) {\n  // Whitelist of trusted domains\n  const trustedDomains = [\n    'cdn.trusted-site.com',\n    'api.your-company.com',\n    'cdn.jsdelivr.net'\n  ];\n  \n  // Parse the URL to get the hostname\n  let url;\n  try {\n    url = new URL(src, window.location.origin);\n  } catch (e) {\n    console.error(\"Invalid URL format\");\n    return;\n  }\n  \n  // Check if the hostname is trusted\n  if (!trustedDomains.includes(url.hostname)) {\n    console.error(\"Untrusted script source domain\");\n    return;\n  }\n  \n  // Now it's safer to load the script\n  const script = document.createElement('script');\n  script.src = src;\n  document.head.appendChild(script);\n}"
    },
    {
      "id": "16c44136-af93-407f-b546-ba03d45786a1",
      "type": "scriptSrcAssignment",
      "severity": "high",
      "title": "Dynamic Script Source Assignment",
      "description": "Setting the src property of script elements with user input allows loading and executing untrusted code.",
      "code": "...const script = document.createElement ('script');\nscript.src = url;\n// Should detect this as vulnerable JSONP / script injection\n...",
      "line": 67,
      "column": 1,
      "recommendation": "Always validate script sources against a whitelist of trusted domains.",
      "recommendationCode": "function loadExternalScript(src) {\n  // Whitelist of trusted domains\n  const trustedDomains = [\n    'cdn.trusted-site.com',\n    'api.your-company.com',\n    'cdn.jsdelivr.net'\n  ];\n  \n  // Parse the URL to get the hostname\n  let url;\n  try {\n    url = new URL(src, window.location.origin);\n  } catch (e) {\n    console.error(\"Invalid URL format\");\n    return;\n  }\n  \n  // Check if the hostname is trusted\n  if (!trustedDomains.includes(url.hostname)) {\n    console.error(\"Untrusted script source domain\");\n    return;\n  }\n  \n  // Now it's safer to load the script\n  const script = document.createElement('script');\n  script.src = src;\n  document.head.appendChild(script);\n}"
    },
    {
      "id": "3777640f-2756-46a0-97d7-de660d7c160c",
      "type": "templateLiteralInjection",
      "severity": "high",
      "title": "Template Literal Injection",
      "description": "Using unescaped user data in template literals that are later injected into HTML can lead to XSS vulnerabilities.",
      "code": "...function createDynamicTemplate (user) {\n  const template = `\n  < div class =\"user - profile\">\n  < h2 > ${\n  user.name}\n  </ h2 >\n  < div class =\"bio\"> ${\n  user.bio}\n  </ div >\n  < script > loadUserData (${\n  user.id}\n  )</ script >\n  </ div >\n  `;\n  document.getElementById ('profile - container').innerHTML = template;\n  ...",
      "line": 73,
      "column": 18,
      "recommendation": "Always sanitize user data before using it in template literals that will be inserted into HTML.",
      "recommendationCode": "// UNSAFE:\n// const template = `<div>${userInput}</div>`;\n// element.innerHTML = template;\n\n// SAFE:\nimport DOMPurify from 'dompurify';\n\n// Option 1: Sanitize before template insertion\nconst sanitizedInput = DOMPurify.sanitize(userInput);\nconst template = `<div>${sanitizedInput}</div>`;\nelement.innerHTML = template;\n\n// Option 2: Sanitize the entire template\nconst unsafeTemplate = `<div>${userInput}</div>`;\nelement.innerHTML = DOMPurify.sanitize(unsafeTemplate);"
    },
    {
      "id": "beb86f9f-8ab2-44e9-a907-1ead8f5a41a2",
      "type": "dangerousInnerHTMLWithVariable",
      "severity": "high",
      "title": "Potentially Dangerous innerHTML Assignment",
      "description": "Setting innerHTML/outerHTML with variables or concatenated strings can lead to XSS vulnerabilities if the input isn't properly sanitized. See OWASP guidelines for handling HTML content safely.",
      "code": "...`;\ndocument.getElementById ('profile - container').innerHTML = template;\n// Should detect XSS in template literals\n...",
      "line": 86,
      "column": 48,
      "recommendation": "Use textContent for text or sanitize HTML content before setting innerHTML. Consider using DOM methods like createElement for more complex structures.",
      "recommendationCode": "// UNSAFE patterns:\n// element.innerHTML = userProvidedData;\n// element.innerHTML = \"<div>\" + message + \"</div>\";\n\n// SAFER approaches:\n// Option 1: For text content\nelement.textContent = userProvidedData;\n\n// Option 2: For simple HTML structures, use DOM methods\nfunction safelyCreateElement(message) {\n  const div = document.createElement('div');\n  div.className = 'message';\n  \n  const strong = document.createElement('strong');\n  strong.textContent = 'Message: ';\n  \n  const span = document.createElement('span');\n  span.textContent = message; // Safely set as text\n  \n  div.appendChild(strong);\n  div.appendChild(span);\n  \n  return div;\n}\n\n// Usage:\nconst messageElement = safelyCreateElement(userMessage);\ncontainer.appendChild(messageElement);\n\n// Option 3: When you need to insert HTML, use sanitization\nimport DOMPurify from 'dompurify';\n\nfunction setHTML(element, htmlContent) {\n  // Configure DOMPurify\n  const sanitizedHTML = DOMPurify.sanitize(htmlContent, {\n    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'span', 'p', 'a', 'ul', 'ol', 'li'],\n    ALLOWED_ATTR: ['href', 'class', 'id', 'target']\n  });\n  \n  // Now safe to use innerHTML\n  element.innerHTML = sanitizedHTML;\n}"
    },
    {
      "id": "15e306fd-5745-4e1f-9701-960f3c279477",
      "type": "scriptCreation",
      "severity": "high",
      "title": "Dynamic Script Creation",
      "description": "Creating script elements dynamically can lead to code injection vulnerabilities, especially when the source or content is influenced by user input.",
      "code": "...if (config.remoteScript) {\n  const script = document.createElement ('script');\n  script.src = config.remoteScript;\n  ...",
      "line": 100,
      "column": 25,
      "recommendation": "Avoid dynamically creating script elements. If necessary, ensure strict validation of sources and use CSP (Content Security Policy).",
      "recommendationCode": "// UNSAFE:\n// const script = document.createElement('script');\n// script.src = userControlledUrl; // Danger: remote code execution\n// document.head.appendChild(script);\n\n// SAFER approaches:\n// 1. Avoid dynamic script creation entirely, use alternative techniques\n//    like fetch() to retrieve data instead\n\n// 2. If you must create scripts dynamically, implement strict validation\nfunction loadScript(url) {\n  // Validate allowed domains\n  const trustedDomains = ['trusted-cdn.com', 'your-domain.com'];\n  const urlObj = new URL(url);\n  \n  if (!trustedDomains.includes(urlObj.hostname)) {\n    console.error('Script domain not allowed:', urlObj.hostname);\n    return Promise.reject(new Error('Untrusted script domain'));\n  }\n  \n  // Use fetch instead of script injection when possible\n  return fetch(url)\n    .then(response => {\n      if (!response.ok) {\n        throw new Error('Network response was not ok');\n      }\n      return response.text();\n    })\n    .then(code => {\n      // Validate the code before executing it\n      // This is difficult to do safely - consider alternatives\n      \n      // Execute in a controlled manner\n      const functionFromCode = new Function(code);\n      return functionFromCode();\n    });\n}"
    },
    {
      "id": "03f2a2cd-aabe-472a-b74a-961cb39a3f10",
      "type": "scriptSrc",
      "severity": "high",
      "title": "Dynamic Script Source Assignment",
      "description": "Setting the src property of script elements with user input allows loading and executing untrusted code.",
      "code": "...const script = document.createElement ('script');\nscript.src = config.remoteScript;\ndocument.head.appendChild (script);\n...",
      "line": 101,
      "column": 1,
      "recommendation": "Always validate script sources against a whitelist of trusted domains.",
      "recommendationCode": "function loadExternalScript(src) {\n  // Whitelist of trusted domains\n  const trustedDomains = [\n    'cdn.trusted-site.com',\n    'api.your-company.com',\n    'cdn.jsdelivr.net'\n  ];\n  \n  // Parse the URL to get the hostname\n  let url;\n  try {\n    url = new URL(src, window.location.origin);\n  } catch (e) {\n    console.error(\"Invalid URL format\");\n    return;\n  }\n  \n  // Check if the hostname is trusted\n  if (!trustedDomains.includes(url.hostname)) {\n    console.error(\"Untrusted script source domain\");\n    return;\n  }\n  \n  // Now it's safer to load the script\n  const script = document.createElement('script');\n  script.src = src;\n  document.head.appendChild(script);\n}"
    },
    {
      "id": "c65ce05a-5c5f-4103-8f43-963c8165ec75",
      "type": "scriptSrcAssignment",
      "severity": "high",
      "title": "Dynamic Script Source Assignment",
      "description": "Setting the src property of script elements with user input allows loading and executing untrusted code.",
      "code": "...const script = document.createElement ('script');\nscript.src = config.remoteScript;\ndocument.head.appendChild (script);\n...",
      "line": 101,
      "column": 1,
      "recommendation": "Always validate script sources against a whitelist of trusted domains.",
      "recommendationCode": "function loadExternalScript(src) {\n  // Whitelist of trusted domains\n  const trustedDomains = [\n    'cdn.trusted-site.com',\n    'api.your-company.com',\n    'cdn.jsdelivr.net'\n  ];\n  \n  // Parse the URL to get the hostname\n  let url;\n  try {\n    url = new URL(src, window.location.origin);\n  } catch (e) {\n    console.error(\"Invalid URL format\");\n    return;\n  }\n  \n  // Check if the hostname is trusted\n  if (!trustedDomains.includes(url.hostname)) {\n    console.error(\"Untrusted script source domain\");\n    return;\n  }\n  \n  // Now it's safer to load the script\n  const script = document.createElement('script');\n  script.src = src;\n  document.head.appendChild(script);\n}"
    },
    {
      "id": "201a9c4f-b410-4264-86da-8976b645d694",
      "type": "postMessageOriginVulnerability",
      "severity": "high",
      "title": "Insecure Cross-Origin Message Handling",
      "description": "This code accepts postMessage events without verifying the origin, which could allow attackers to inject data from malicious websites.",
      "code": "...function setupMessageListener () {\n  window.addEventListener ('message', function (event) {\n    // No origin checking\n    ...",
      "line": 119,
      "column": 1,
      "recommendation": "Always validate the origin of incoming messages before processing them.",
      "recommendationCode": "// UNSAFE:\n// window.addEventListener('message', function(event) {\n//   const data = event.data;\n//   // Process data without origin check...\n// });\n\n// SAFE:\nwindow.addEventListener('message', function(event) {\n  // Always verify the origin of incoming messages\n  const trustedOrigins = ['https://trusted-site.com', 'https://api.your-app.com'];\n  \n  if (!trustedOrigins.includes(event.origin)) {\n    console.error('Message received from untrusted origin:', event.origin);\n    return;\n  }\n  \n  // It's safe to process the message now\n  try {\n    const data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;\n    \n    // Process data...\n    \n  } catch (error) {\n    console.error('Error processing message:', error);\n  }\n});\n\n// When sending messages, always specify target origin:\ntargetWindow.postMessage(data, 'https://specific-target.com');  // Never use '*'"
    },
    {
      "id": "b2e037ca-52aa-4b27-8f0b-2eb7c58ef3b5",
      "type": "scriptCreation",
      "severity": "high",
      "title": "Dynamic Script Creation",
      "description": "Creating script elements dynamically can lead to code injection vulnerabilities, especially when the source or content is influenced by user input.",
      "code": "...function loadMixedContent (userId) {\n  const script = document.createElement ('script');\n  script.src = 'http:// api.example.com / user /' + userId + '/ profile.js';\n  ...",
      "line": 202,
      "column": 25,
      "recommendation": "Avoid dynamically creating script elements. If necessary, ensure strict validation of sources and use CSP (Content Security Policy).",
      "recommendationCode": "// UNSAFE:\n// const script = document.createElement('script');\n// script.src = userControlledUrl; // Danger: remote code execution\n// document.head.appendChild(script);\n\n// SAFER approaches:\n// 1. Avoid dynamic script creation entirely, use alternative techniques\n//    like fetch() to retrieve data instead\n\n// 2. If you must create scripts dynamically, implement strict validation\nfunction loadScript(url) {\n  // Validate allowed domains\n  const trustedDomains = ['trusted-cdn.com', 'your-domain.com'];\n  const urlObj = new URL(url);\n  \n  if (!trustedDomains.includes(urlObj.hostname)) {\n    console.error('Script domain not allowed:', urlObj.hostname);\n    return Promise.reject(new Error('Untrusted script domain'));\n  }\n  \n  // Use fetch instead of script injection when possible\n  return fetch(url)\n    .then(response => {\n      if (!response.ok) {\n        throw new Error('Network response was not ok');\n      }\n      return response.text();\n    })\n    .then(code => {\n      // Validate the code before executing it\n      // This is difficult to do safely - consider alternatives\n      \n      // Execute in a controlled manner\n      const functionFromCode = new Function(code);\n      return functionFromCode();\n    });\n}"
    },
    {
      "id": "dfe81aac-1af7-45fc-ad85-5fdcc8c3cd9a",
      "type": "scriptSrc",
      "severity": "high",
      "title": "Dynamic Script Source Assignment",
      "description": "Setting the src property of script elements with user input allows loading and executing untrusted code.",
      "code": "...const script = document.createElement ('script');\nscript.src = 'http:// api.example.com / user /' + userId + '/ profile.js';\n// Mixed content vulnerability (http in https)\n...",
      "line": 203,
      "column": 1,
      "recommendation": "Always validate script sources against a whitelist of trusted domains.",
      "recommendationCode": "function loadExternalScript(src) {\n  // Whitelist of trusted domains\n  const trustedDomains = [\n    'cdn.trusted-site.com',\n    'api.your-company.com',\n    'cdn.jsdelivr.net'\n  ];\n  \n  // Parse the URL to get the hostname\n  let url;\n  try {\n    url = new URL(src, window.location.origin);\n  } catch (e) {\n    console.error(\"Invalid URL format\");\n    return;\n  }\n  \n  // Check if the hostname is trusted\n  if (!trustedDomains.includes(url.hostname)) {\n    console.error(\"Untrusted script source domain\");\n    return;\n  }\n  \n  // Now it's safer to load the script\n  const script = document.createElement('script');\n  script.src = src;\n  document.head.appendChild(script);\n}"
    },
    {
      "id": "58dc72f6-6569-4ac9-b994-9e13b3541a3a",
      "type": "scriptSrcAssignment",
      "severity": "high",
      "title": "Dynamic Script Source Assignment",
      "description": "Setting the src property of script elements with user input allows loading and executing untrusted code.",
      "code": "...const script = document.createElement ('script');\nscript.src = 'http:// api.example.com / user /' + userId + '/ profile.js';\n// Mixed content vulnerability (http in https)\n...",
      "line": 203,
      "column": 1,
      "recommendation": "Always validate script sources against a whitelist of trusted domains.",
      "recommendationCode": "function loadExternalScript(src) {\n  // Whitelist of trusted domains\n  const trustedDomains = [\n    'cdn.trusted-site.com',\n    'api.your-company.com',\n    'cdn.jsdelivr.net'\n  ];\n  \n  // Parse the URL to get the hostname\n  let url;\n  try {\n    url = new URL(src, window.location.origin);\n  } catch (e) {\n    console.error(\"Invalid URL format\");\n    return;\n  }\n  \n  // Check if the hostname is trusted\n  if (!trustedDomains.includes(url.hostname)) {\n    console.error(\"Untrusted script source domain\");\n    return;\n  }\n  \n  // Now it's safer to load the script\n  const script = document.createElement('script');\n  script.src = src;\n  document.head.appendChild(script);\n}"
    },
    {
      "id": "74cce878-098d-4b83-8c49-e4a6e16326f1",
      "type": "scriptElement",
      "severity": "medium",
      "title": "Dynamic Script Creation",
      "description": "Dynamically creating script elements and setting their content or src attribute can execute malicious code.",
      "code": "...const url = protocol + '://' + data.domain + '/ api?query =' + data.query;\nconst script = document.createElement ('script');\nscript.src = url;\n...",
      "line": 66,
      "column": 16,
      "recommendation": "Never load scripts from untrusted sources. Use a whitelist approach to validate script URLs before loading.",
      "recommendationCode": "function loadScript(src) {\n  // Whitelist of allowed script sources\n  const allowedSources = [\n    'https://trusted-cdn.com/',\n    'https://your-own-domain.com/scripts/'\n  ];\n  \n  // Check if URL is from allowed source\n  const isAllowed = allowedSources.some(source => \n    src.startsWith(source));\n    \n  if (!isAllowed) {\n    console.error(\"Blocked loading script from untrusted source\");\n    return;\n  }\n  \n  const script = document.createElement('script');\n  script.src = src;\n  document.head.appendChild(script);\n}"
    },
    {
      "id": "7f69fddc-c559-41a7-9c24-35b9ab6b27cd",
      "type": "domClobberingViaID",
      "severity": "medium",
      "title": "Potential DOM Clobbering Vulnerability",
      "description": "Using getElementById with variable inputs can be exploited via DOM clobbering attacks, where attackers inject elements with controlled IDs.",
      "code": "...`;\ndocument.getElementById ('profile - container').innerHTML = template;\n// Should detect XSS in template literals\n...",
      "line": 86,
      "column": 9,
      "recommendation": "Use constant, hardcoded IDs with getElementById or validate ID inputs against a strict allowlist.",
      "recommendationCode": "// UNSAFE patterns:\n// const element = document.getElementById(userProvidedId);\n// document.getElementById(params.get('section')).innerHTML = content;\n\n// SAFER approaches:\n// Option 1: Use hardcoded IDs (preferred)\nconst element = document.getElementById('user-profile');\n\n// Option 2: If dynamic IDs are needed, validate against an allowlist\nfunction getElementByValidatedId(id) {\n  // Define allowed IDs\n  const allowedIds = ['profile', 'settings', 'dashboard', 'messages'];\n  \n  // Validate the ID\n  if (typeof id !== 'string' || !allowedIds.includes(id)) {\n    console.error('Invalid or disallowed element ID:', id);\n    return null;\n  }\n  \n  return document.getElementById(id);\n}\n\n// Usage:\nconst section = getElementByValidatedId(sectionId);\nif (section) {\n  section.textContent = data;\n}"
    },
    {
      "id": "e25ae2e0-8087-44bb-ac79-da3307018bd1",
      "type": "objectDefineProperty",
      "severity": "medium",
      "title": "Potential Prototype Pollution via defineProperty",
      "description": "Using Object.defineProperty with user-controlled property names can lead to prototype pollution or object property clobbering.",
      "code": "...// Vulnerable approach to setting properties\nObject.defineProperty (window, 'appConfig', {\n  value: config,\n  ...",
      "line": 92,
      "column": 1,
      "recommendation": "Validate object and property names before using defineProperty, especially with user input.",
      "recommendationCode": "// Instead of:\n// Object.defineProperty(target, userInput, { value: 'some value' });\n\n// Validate the property name first:\nfunction safeDefineProperty(obj, propName, descriptor) {\n  // Disallow prototype chain or constructor manipulation\n  if (propName === '__proto__' || \n      propName === 'constructor' || \n      propName === 'prototype') {\n    console.error('Attempted to define unsafe property:', propName);\n    return false;\n  }\n  \n  // Only allow whitelisted properties if using user input\n  const allowedProps = ['name', 'description', 'value', 'isActive'];\n  if (!allowedProps.includes(propName)) {\n    console.error('Property name not in allowed list:', propName);\n    return false;\n  }\n  \n  Object.defineProperty(obj, propName, descriptor);\n  return true;\n}"
    },
    {
      "id": "f88bf07d-e69b-45cf-8981-cabeba34691e",
      "type": "scriptElement",
      "severity": "medium",
      "title": "Dynamic Script Creation",
      "description": "Dynamically creating script elements and setting their content or src attribute can execute malicious code.",
      "code": "...if (config.remoteScript) {\n  const script = document.createElement ('script');\n  script.src = config.remoteScript;\n  ...",
      "line": 100,
      "column": 16,
      "recommendation": "Never load scripts from untrusted sources. Use a whitelist approach to validate script URLs before loading.",
      "recommendationCode": "function loadScript(src) {\n  // Whitelist of allowed script sources\n  const allowedSources = [\n    'https://trusted-cdn.com/',\n    'https://your-own-domain.com/scripts/'\n  ];\n  \n  // Check if URL is from allowed source\n  const isAllowed = allowedSources.some(source => \n    src.startsWith(source));\n    \n  if (!isAllowed) {\n    console.error(\"Blocked loading script from untrusted source\");\n    return;\n  }\n  \n  const script = document.createElement('script');\n  script.src = src;\n  document.head.appendChild(script);\n}"
    },
    {
      "id": "481b6fbb-8ef9-4ae0-9a07-dd9dd04cb445",
      "type": "postMessageNoOriginCheck",
      "severity": "medium",
      "title": "Missing Origin Check in postMessage Handler",
      "description": "Processing message events without checking the origin can lead to cross-origin attacks.",
      "code": "...function setupMessageListener () {\n  window.addEventListener ('message', function (event) {\n    // No origin checking\n    try {\n      const data = JSON.parse (event.data);\n      if (data.type === 'command') {\n        eval (data.payload);\n        // Should detect this as postMessage + eval vulnerability\n      }\n    }\n    catch (e) {\n      console.error ('Invalid message format', e);\n    }\n  }\n  ...",
      "line": 119,
      "column": 1,
      "recommendation": "Always verify the origin of messages before processing them to ensure they come from trusted sources.",
      "recommendationCode": "// UNSAFE: No origin check\n// window.addEventListener('message', (event) => {\n//   const data = event.data;\n//   document.getElementById('output').innerHTML = data.message;\n// });\n\n// SECURE: With proper origin validation\nwindow.addEventListener('message', (event) => {\n  // ALWAYS check origin before processing messages\n  const trustedOrigins = ['https://trusted-site.com', 'https://partner-site.org'];\n  \n  if (!trustedOrigins.includes(event.origin)) {\n    console.error('Received message from untrusted origin:', event.origin);\n    return; // Ignore messages from untrusted origins\n  }\n  \n  // Now safe to process the message\n  try {\n    const data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;\n    // Use safe DOM manipulation\n    document.getElementById('output').textContent = data.message;\n  } catch (e) {\n    console.error('Error processing message:', e);\n  }\n});"
    },
    {
      "id": "e3000312-0846-4b90-b44e-118ef6b7c67c",
      "type": "postMessageOrigin",
      "severity": "medium",
      "title": "postMessage Without Origin Check",
      "description": "Handling postMessage events without verifying the origin can lead to XSS attacks from malicious websites.",
      "code": "...function setupMessageListener () {\n  window.addEventListener ('message', function (event) {\n    // No origin checking\n    ...",
      "line": 119,
      "column": 8,
      "recommendation": "Always validate the origin of received messages.",
      "recommendationCode": "// Instead of:\nwindow.addEventListener('message', function(event) {\n  // Process event.data without checking origin\n  processMessage(event.data);\n});\n\n// Add origin validation:\nwindow.addEventListener('message', function(event) {\n  // Check that the origin is from a trusted domain\n  const trustedOrigins = ['https://trusted-site.com', 'https://partner-site.org'];\n  \n  if (trustedOrigins.includes(event.origin)) {\n    // Safe to process the message\n    processMessage(event.data);\n  } else {\n    console.warn('Received message from untrusted origin:', event.origin);\n  }\n});"
    },
    {
      "id": "443466c6-8a79-4902-a3de-71a18c8b8e6d",
      "type": "documentGetElementById",
      "severity": "low",
      "title": "Potential DOM Clobbering Vulnerability",
      "description": "Using getElementById with a fixed string can be exploited through DOM clobbering if the ID is also used as an object property.",
      "code": "...`;\ndocument.getElementById ('profile - container').innerHTML = template;\n// Should detect XSS in template literals\n...",
      "line": 86,
      "column": 1,
      "recommendation": "Ensure IDs used with getElementById are not also used as object property names in your code.",
      "recommendationCode": "// Vulnerable pattern:\n// const config = {};\n// config.endpoint = document.getElementById('endpoint').value;\n// fetch(config.endpoint + '/data');\n\n// Safer approach:\nfunction getElementValueById(id) {\n  const element = document.getElementById(id);\n  // Validate element is of expected type\n  if (element && element instanceof HTMLInputElement) {\n    return element.value;\n  }\n  return null;\n}\n\n// Then use with validation:\nconst endpoint = getElementValueById('endpoint');\nif (endpoint && isValidUrl(endpoint)) {\n  fetch(endpoint + '/data');\n}"
    },
    {
      "id": "b75a99da-7470-45e4-8182-22e8c8d6d52d",
      "type": "innerHTML",
      "severity": "critical",
      "title": "innerHTML Injection",
      "description": "Unfiltered user input is directly used with innerHTML, allowing attackers to inject and execute malicious scripts. See OWASP guidelines for handling HTML content safely.",
      "code": "...`;\ndocument.getElementById ('profile - container').innerHTML = template;\n// Should detect XSS in template literals\n...",
      "line": 86,
      "column": 48,
      "recommendation": "Always sanitize user input before inserting it into the DOM. Use textContent instead of innerHTML or implement a library like DOMPurify.",
      "recommendationCode": "// Option 1: Use textContent (safest)\ndocument.getElementById('output').textContent = userInput;\n\n// Option 2: Use DOMPurify library\ndocument.getElementById('output').innerHTML = DOMPurify.sanitize(userInput);"
    },
    {
      "id": "1273e6ca-7a0b-493c-863e-6e149b01cbf7",
      "type": "eval",
      "severity": "critical",
      "title": "Unsafe eval() Usage",
      "description": "The use of eval() with user input creates a severe XSS vulnerability that allows arbitrary code execution. This is one of the most serious XSS vulnerabilities as it allows direct code execution.",
      "code": "...if (data.type === 'command') {\n  eval (data.payload);\n  // Should detect this as postMessage + eval vulnerability\n  ...",
      "line": 124,
      "column": 1,
      "recommendation": "Avoid using eval() with user input. For mathematical expressions, use safer alternatives like math.js library or Function constructor with proper input validation.",
      "recommendationCode": "// Option 1: Use a math library\nfunction calculateExpression() {\n  const expr = document.getElementById('expression').value;\n  try {\n    // Validate that the input contains only mathematical expressions\n    if (!/^[0-9\\+\\-\\*\\/\\(\\)\\.\\s]*$/.test(expr)) {\n      throw new Error(\"Invalid expression\");\n    }\n    const result = math.evaluate(expr); // Using math.js\n    return result;\n  } catch(e) {\n    return \"Error: Invalid expression\";\n  }\n}"
    },
    {
      "id": "e21cd7a0-2d25-450e-80db-f6048e228b2a",
      "type": "formCSRFVulnerability",
      "severity": "critical",
      "title": "Form Submission Without CSRF Protection",
      "description": "This code creates and submits a form without a CSRF token, allowing attackers to forge requests on behalf of authenticated users.",
      "code": "...document.body.appendChild (form);\nform.submit ();\n// Should detect CSRF vulnerability\n...",
      "line": 148,
      "column": 1,
      "recommendation": "Always include CSRF tokens in forms and validate them on the server.",
      "recommendationCode": "// UNSAFE - Form without CSRF token:\n// const form = document.createElement('form');\n// form.method = 'POST';\n// form.action = '/api/update-profile';\n// form.submit();\n\n// SAFE - Include CSRF token in form:\nfunction createSecureForm(action, method) {\n  const form = document.createElement('form');\n  form.action = action;\n  form.method = method;\n  \n  // Get CSRF token from meta tag or cookie\n  const csrfToken = document.querySelector('meta[name=\"csrf-token\"]')?.getAttribute('content') || \n                   getCookie('XSRF-TOKEN');\n  \n  if (!csrfToken) {\n    console.error('Missing CSRF token - cannot create secure form');\n    return null;\n  }\n  \n  // Add CSRF token as hidden field\n  const tokenField = document.createElement('input');\n  tokenField.type = 'hidden';\n  tokenField.name = 'csrf_token';\n  tokenField.value = csrfToken;\n  form.appendChild(tokenField);\n  \n  return form;\n}\n\n// Usage:\nconst secureForm = createSecureForm('/api/update-profile', 'POST');\nif (secureForm) {\n  // Add form fields...\n  document.body.appendChild(secureForm);\n  secureForm.submit();\n}"
    },
    {
      "id": "d95fb562-10d2-45ea-8c66-3567bce9816b",
      "type": "eval",
      "severity": "critical",
      "title": "Unsafe eval() Usage",
      "description": "The use of eval() with user input creates a severe XSS vulnerability that allows arbitrary code execution. This is one of the most serious XSS vulnerabilities as it allows direct code execution.",
      "code": "...function processUserCommand (cmd) {\n  const execFn = new Function ('cmd', 'return eval (cmd)');\n  return execFn (cmd);\n  ...",
      "line": 153,
      "column": 45,
      "recommendation": "Avoid using eval() with user input. For mathematical expressions, use safer alternatives like math.js library or Function constructor with proper input validation.",
      "recommendationCode": "// Option 1: Use a math library\nfunction calculateExpression() {\n  const expr = document.getElementById('expression').value;\n  try {\n    // Validate that the input contains only mathematical expressions\n    if (!/^[0-9\\+\\-\\*\\/\\(\\)\\.\\s]*$/.test(expr)) {\n      throw new Error(\"Invalid expression\");\n    }\n    const result = math.evaluate(expr); // Using math.js\n    return result;\n  } catch(e) {\n    return \"Error: Invalid expression\";\n  }\n}"
    },
    {
      "id": "623eba94-07d4-42d3-b047-35f680e1bdbe",
      "type": "functionConstructor",
      "severity": "critical",
      "title": "Function Constructor Misuse",
      "description": "The Function constructor is similar to eval() and can execute arbitrary code if given user input.",
      "code": "...function processUserCommand (cmd) {\n  const execFn = new Function ('cmd', 'return eval (cmd)');\n  return execFn (cmd);\n  ...",
      "line": 153,
      "column": 16,
      "recommendation": "Avoid using the Function constructor with user input. Use safer alternatives for dynamic code execution.",
      "recommendationCode": "// Instead of:\nconst fn = new Function('param', userCode);\n\n// Consider a more restrictive approach:\n// 1. Use a template literals with fixed code\nconst fn = (param) => {\n  // Fixed operations here\n  return param * 2;\n};\n\n// 2. Or if you need configurability, use a whitelist approach\nconst allowedOperations = {\n  'double': (x) => x * 2,\n  'square': (x) => x * x,\n  'increment': (x) => x + 1\n};\n\n// Then use the selected operation safely\nconst operation = allowedOperations[userSelection] || ((x) => x);\nconst result = operation(value);"
    }
  ],
  "summary": {
    "critical": 5,
    "high": 12,
    "medium": 6,
    "low": 1,
    "info": 0,
    "total": 24,
    "uniqueTypes": 16,
    "passedChecks": 141
  },
  "scannedAt": "2025-03-27T11:36:25.352Z"
}